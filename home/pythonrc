# -----------------------------------------------------------------------------
# Python repl config
# -----------------------------------------------------------------------------

import datetime
import math
import os
import random
import re
import sys
from math import *
from pydoc import pager

try:
    from see import see
except ImportError:
    see = dir


class Term:
    reset  = "\x1b[0m"
    bold   = "\x1b[1m"
    dim    = "\x1b[2m"
    unbold = "\x1b[21m"
    undim  = "\x1b[22m"
    red    = "\x1b[31m"
    green  = "\x1b[32m"
    yellow = "\x1b[33m"
    blue   = "\x1b[34m"
    pink   = "\x1b[35m"
    cyan   = "\x1b[36m"

class MyPrompt:

    @classmethod
    def setup(cls):
        version = '.'.join(str(s) for s in sys.version_info[:2])
        sys.ps1 = '%s ' % ''.join((
            '%s(%s' % (Term.dim, Term.undim),
            'py%s' % version,
            '%s)%s' % (Term.dim, Term.undim),
            '%s>%s' % (Term.blue, Term.reset),
            ))
        sys.ps2 = '%s ' % ''.join((
            '%s.%s' % (Term.blue, Term.reset),
            ))

MyPrompt.setup()


if sys.version_info[0] < 3:
    try:
        import rlcompleter
        if 'libedit' in rlcompleter.readline.__doc__:
            rlcompleter.readline.parse_and_bind('bind ^I rl_complete')
        else:
            rlcompleter.readline.parse_and_bind('tab: complete')
    except ImportError:
        print("Install readline for tab completion.")

print('')


def take(seq, count=1):
    queue = []
    for item in seq:
        queue.append(item)
        if len(queue) == count:
            yield tuple(queue)
            queue = []

    if queue:
        yield tuple(queue)


def pairs(seq):
    return take(seq, 2)


def enhex(seq):
    if isinstance(seq, str):
        seq = seq.encode('utf-8')
    return ' '.join(hex(b)[2:].zfill(2) for b in seq).upper()


def dehex(s, utf8=True):
    s = ''.join(s.lower().split())
    if not all(c in '0123456789abcdef' for c in s):
        raise ValueError('Not a hex string')
    byteseq = bytes(int(''.join(p), 16) for p in pairs(s))
    if utf8:
        try:
            return byteseq.decode('utf-8')
        except UnicodeDecodeError:
            pass
    return byteseq
